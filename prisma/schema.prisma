// Prisma schema for Family OS
// NextAuth.js compatible + Calendar integration

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// NextAuth.js required models
model User {
  id                     String                  @id @default(cuid())
  name                   String?
  email                  String                  @unique
  emailVerified          DateTime?
  image                  String?
  householdId            String?
  phoneNumber            String?                 // For SMS notifications
  phoneVerified          Boolean                 @default(false)
  accounts               Account[]
  sessions               Session[]
  household              Household?              @relation(fields: [householdId], references: [id])
  familyMember           FamilyMember?
  ritualSessions         RitualSession[]
  notificationPreference NotificationPreference?
  pushSubscriptions      PushSubscription[]
  notificationLogs       NotificationLog[]
  nudgesSent             PartnerNudge[]          @relation("NudgeSent")
  nudgesReceived         PartnerNudge[]          @relation("NudgeReceived")
  insightsResolved       Insight[]               @relation("InsightResolver")
  createdAt              DateTime                @default(now())
  updatedAt              DateTime                @updatedAt
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// Family OS specific models
model Household {
  id              String                @id @default(cuid())
  name            String                @default("Our Family")
  members         FamilyMember[]
  users           User[]
  invites         HouseholdInvite[]
  ritualWeeks     HouseholdRitualWeek[]
  children        ChildProfile[]
  tasks           Task[]
  weekSnapshots   WeekSnapshot[]
  insights        Insight[]
  caretakerLinks  CaretakerAccess[]
  createdAt       DateTime              @default(now())
  updatedAt       DateTime              @updatedAt
}

// Household-level ritual tracking for partner sync
model HouseholdRitualWeek {
  id          String          @id @default(cuid())
  householdId String
  weekKey     String          // e.g., "2024-W52"
  status      String          @default("pending") // pending, in_progress, needs_sync, completed
  household   Household       @relation(fields: [householdId], references: [id], onDelete: Cascade)
  sessions    RitualSession[]
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt

  @@unique([householdId, weekKey])
}

model HouseholdInvite {
  id          String    @id @default(cuid())
  householdId String
  email       String
  token       String    @unique @default(cuid())
  status      String    @default("pending") // pending | accepted | expired
  invitedBy   String    // userId who sent invite
  expiresAt   DateTime
  household   Household @relation(fields: [householdId], references: [id], onDelete: Cascade)
  createdAt   DateTime  @default(now())

  @@unique([householdId, email])
}

model FamilyMember {
  id          String    @id @default(cuid())
  userId      String    @unique
  householdId String
  role        String    // "parent_a" | "parent_b"
  displayName String
  color       String    @default("#7C6A5D")
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  household   Household @relation(fields: [householdId], references: [id], onDelete: Cascade)
  calendars   ConnectedCalendar[]
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
}

model ConnectedCalendar {
  id               String       @id @default(cuid())
  familyMemberId   String
  googleCalendarId String
  name             String
  color            String
  included         Boolean      @default(true)
  lastSyncedAt     DateTime?
  familyMember     FamilyMember @relation(fields: [familyMemberId], references: [id], onDelete: Cascade)
  createdAt        DateTime     @default(now())
  updatedAt        DateTime     @updatedAt

  @@unique([familyMemberId, googleCalendarId])
}

// Ritual state persistence
model RitualSession {
  id              String               @id @default(cuid())
  userId          String
  weekKey         String               // "2024-W50" (ISO week format)
  currentStep     Int                  @default(1)
  completedAt     DateTime?
  householdWeekId String?
  user            User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  householdWeek   HouseholdRitualWeek? @relation(fields: [householdWeekId], references: [id])
  prepItems       PrepItemState[]
  decisions       DecisionState[]
  createdAt       DateTime             @default(now())
  updatedAt       DateTime             @updatedAt

  @@unique([userId, weekKey])
}

model PrepItemState {
  id              String        @id @default(cuid())
  ritualSessionId String
  itemKey         String        // "event123-0" or "prep-5-1"
  done            Boolean       @default(false)
  ritualSession   RitualSession @relation(fields: [ritualSessionId], references: [id], onDelete: Cascade)
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  @@unique([ritualSessionId, itemKey])
}

model DecisionState {
  id              String        @id @default(cuid())
  ritualSessionId String
  conflictId      String        // e.g., "conflict-5-6"
  resolution      String?       // The selected option text
  resolved        Boolean       @default(false)
  ritualSession   RitualSession @relation(fields: [ritualSessionId], references: [id], onDelete: Cascade)
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  @@unique([ritualSessionId, conflictId])
}

// Notification system models
model NotificationPreference {
  id                   String   @id @default(cuid())
  userId               String   @unique

  // Email preferences
  emailDigest          Boolean  @default(true)
  emailDigestDay       String   @default("monday")
  emailDigestTime      String   @default("07:00")
  emailPartnerComplete Boolean  @default(true)

  // Push preferences
  pushEnabled          Boolean  @default(true)
  pushPartnerComplete  Boolean  @default(true)
  pushPartnerWaiting   Boolean  @default(true)
  pushPrepReminder     Boolean  @default(true)
  pushNudge            Boolean  @default(true)

  // Quiet hours
  quietHoursEnabled    Boolean  @default(false)
  quietHoursStart      String   @default("22:00")
  quietHoursEnd        String   @default("07:00")

  unsubscribeToken     String   @unique @default(cuid())

  user                 User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
}

model PushSubscription {
  id        String   @id @default(cuid())
  userId    String
  endpoint  String   @unique
  p256dh    String
  auth      String
  userAgent String?
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@index([userId])
}

model NotificationLog {
  id        String   @id @default(cuid())
  userId    String
  type      String   // email_digest, push_partner_complete, push_nudge
  channel   String   // email, push
  status    String   // sent, failed, delivered
  metadata  Json?
  error     String?
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@index([userId, type])
}

model PartnerNudge {
  id          String   @id @default(cuid())
  fromUserId  String
  toUserId    String
  householdId String
  weekKey     String
  message     String?
  sentAt      DateTime @default(now())

  fromUser    User     @relation("NudgeSent", fields: [fromUserId], references: [id])
  toUser      User     @relation("NudgeReceived", fields: [toUserId], references: [id])

  @@index([toUserId, weekKey])
}

// Child profiles for family tracking
model ChildProfile {
  id          String    @id @default(cuid())
  householdId String
  name        String
  color       String    @default("#C17F59")
  avatarEmoji String?
  birthdate   DateTime?
  household   Household @relation(fields: [householdId], references: [id], onDelete: Cascade)
  tasks       Task[]
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([householdId])
}

// Task management (event-prep, decision-followup, or standalone)
model Task {
  id          String        @id @default(cuid())
  householdId String
  weekKey     String
  title       String
  description String?
  type        String        // "event-prep" | "decision-followup" | "standalone"
  status      String        @default("pending") // "pending" | "in_progress" | "completed"
  priority    String        @default("normal") // "low" | "normal" | "high"
  assignedTo  String        // "parent_a" | "parent_b" | "both"
  dueDate     DateTime?
  childId     String?
  child       ChildProfile? @relation(fields: [childId], references: [id], onDelete: SetNull)
  eventId     String?
  household   Household     @relation(fields: [householdId], references: [id], onDelete: Cascade)
  completedAt DateTime?
  completedBy String?
  createdBy   String
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  @@index([householdId, weekKey])
  @@index([householdId, status])
}

// Weekly analytics snapshots for trends
model WeekSnapshot {
  id                 String    @id @default(cuid())
  householdId        String
  weekKey            String
  parentAEvents      Int       @default(0)
  parentBEvents      Int       @default(0)
  parentAHandoffs    Int       @default(0)
  parentBHandoffs    Int       @default(0)
  parentASoloDays    Int       @default(0)
  parentBSoloDays    Int       @default(0)
  totalEvents        Int       @default(0)
  conflictCount      Int       @default(0)
  conflictResolved   Int       @default(0)
  travelDays         Int       @default(0)
  intensity          String    @default("light")
  ritualCompletedAt  DateTime?
  prepItemsTotal     Int       @default(0)
  prepItemsCompleted Int       @default(0)
  tasksTotal         Int       @default(0)
  tasksCompleted     Int       @default(0)
  household          Household @relation(fields: [householdId], references: [id], onDelete: Cascade)
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt

  @@unique([householdId, weekKey])
}

// Proactive intelligence insights (SMS-first)
model Insight {
  id           String    @id @default(cuid())
  householdId  String
  type         String    // calendar_gap, conflict, coverage_gap, load_imbalance, prep_reminder
  severity     String    // high, medium, low
  title        String
  description  String
  smsMessage   String    // The SMS that was/will be sent
  status       String    @default("pending") // pending, sent, resolved, dismissed
  resolvedById String?
  resolution   String?   // What action was taken
  eventIds     String[]  // Related calendar event IDs
  metadata     Json?     // Additional context data
  sentAt       DateTime?
  resolvedAt   DateTime?
  household    Household @relation(fields: [householdId], references: [id], onDelete: Cascade)
  resolvedBy   User?     @relation("InsightResolver", fields: [resolvedById], references: [id])
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  @@index([householdId, status])
  @@index([householdId, type])
}

// Temporary access links for caretakers (babysitters, grandparents, etc.)
model CaretakerAccess {
  id           String    @id @default(cuid())
  householdId  String
  token        String    @unique @default(cuid())
  name         String    // "Grandma", "Babysitter Sarah"
  validFrom    DateTime
  validUntil   DateTime
  accessedAt   DateTime?
  accessCount  Int       @default(0)
  notes        String?   // Special instructions
  createdById  String
  household    Household @relation(fields: [householdId], references: [id], onDelete: Cascade)
  createdAt    DateTime  @default(now())

  @@index([token])
  @@index([householdId])
}
